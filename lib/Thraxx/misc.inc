# Thraxx miscellaneous routines
# $Id$
use Storable;
use strict;

sub in_array
{
	my ($elem, $arr) = @_;
#	return FALSE() unless defined $elem;
	if ($elem =~ /\^d+$/)
	{
		# Numerical search
		for (@$arr)
		{
			return TRUE() if $elem == $_;
		}
	} else {
		# String search
		for (@$arr)
		{
			return TRUE() if $elem eq $_;
		}
	}

	return FALSE();
}

sub in_hash
{
	my ($elem, $hash) = @_;
	my ($k, $v);
	if ($elem =~ /^\d+$/)
	{
		# Numerical search
		while (($k, $v) = each %$hash)
		{
			return $k if $elem == $v;
		}
	} else {
		# String search
		while (($k, $v) = each %$hash)
		{
			return $k if $elem eq $v;
		}
	}

	return undef;
}

sub write_config
{
	my ($this) = @_;
	my @directives = qw( simult_sessions dbh_host
		dbh_username dbh_password dbh_type
		dbh_database user_fields crypt_key
	);

	# Update %$this?

	my ($path) = ($INC{'Thraxx.pm'} =~ m!(.*/)!);
	my $file = "$path/thraxx-config.inc.TEST";
	my $output = "";
	
	foreach my $directive (@directives)
	{
		$output .= '$prefs{"' . $directive . '"} = ' .
			$this->flatten_var($directive, $this->{$directive}) .
			";\n";
	}

	local *CONFIG;
	if (open CONFIG, "> $file")
	{
		print CONFIG <<EOF;
# Automatically generated by Thraxx

$output
EOF
		close CONFIG;
	} else {
		$this->throw("Unable to write updated configuration; file: $file");
	}
}

sub flatten_var
{
	my ($this, $directive, $value) = @_;
	my @strings = qw(dbh_username dbh_password
		dbh_database dbh_host crypt_key);
	my @globs = qw(dbh_type);
	my @hashes = qw(user_fields);
	my %constants = (
		simult_sessions => {
			SESSION_MULT_ALLOW	=> SESSION_MULT_ALLOW(),
			SESSION_MULT_DISALLOW	=> SESSION_MULT_DISALLOW(),
			SESSION_MULT_CLEAR	=> SESSION_MULT_CLEAR(),
		},
	);
	if (ref \$value eq "SCALAR" && in_array($directive, \@strings))
	{
		# String
		return flatten_string($value);
	} elsif ($value =~ /^[a-zA-Z0-9:]+$/ && ref $constants{$directive} eq "HASH" &&
		defined(my $key = in_hash($value, $constants{$directive}))) {
		# Constant
		return $key;
	} elsif (ref \$value eq "GLOB" && in_array($directive, \@globs)) {
		# Typeglob
		return $value;
	} elsif (ref $value eq "HASH" && in_array($directive, \@hashes)) {
		# Hash
		return flatten_hash($value);
	} else {
		$this->throw("Invalid directive/directive value; directive: $directive; value: $value");
	}
}

sub flatten_string
{
	my ($value) = @_;
	# Escape quotes
	$value =~ s/['\\]/\\$&/g;
	return qq!'$value'!;
}

sub flatten_array
{
}

sub flatten_hash
{
	my ($value) = @_;
	my $ret = "{\n\t";
	my ($k, $v);
	my $ref;
	while (($k, $v) = each(%$value))
	{
		$ret .= flatten_string($k) . '=>';
		$ref = ref $v;
		if ($ref eq "HASH")
		{
			$ret .= flatten_hash($v);
		} else {
			$ret .= flatten_string($v);
		}
		$ret .= ", ";
	}
	$ret .= "}";
}

# We will promise to call throw() on our first
# argument regardless of what it is, so during the
# low-level initialization stages, as long as we're
# given something with a throw() (such as Thraxx::throw()
# or WASP::throw() (hint, hint)), then all is well.
sub slurp_file
{
	my ($this, $file) = @_;
	local ($/, *F);
	my $data;
	if (open F, "< $file")
	{
		$data = <F>;
		close F;
	} else {
		$this->throw("Unable to open() file; file: $file; mode: read");
	}
	return $data;
}

return TRUE();
